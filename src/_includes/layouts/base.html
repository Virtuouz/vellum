<!doctype html>
<html
  lang="en"
  class=" mx-auto my-0 scroll-smooth scroll-pt-32 overflow-x-hidden"
    _="
  on keydown
  log event.key
  if (event.ctrlKey and event.key == 'k') or (event.metaKey and event.key == 'k')
  then
  event.preventDefault()
  set modal to #modal-search
  modal.show()
  transition #modal-search opacity to 1 over 0.2s
  end
"
>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    {% include "partials/meta-info.html" %} {% include
    "partials/google-fonts.html" %}
    <link
      rel="alternate"
      type="application/rss+xml"
      href="{{ site.url }}/feed.xml"
    />
    <script>
  // Immediately-invoked function to set the theme on initial load.
  (function() {
    const lightLogo = document.getElementById('logoLight');
    const darkLogo = document.getElementById('logoDark');
    if (
      localStorage.theme === 'dark' || 
      (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)
    ) {
      document.documentElement.classList.add('dark');
      lightLogo.classList.add('hidden');
      darkLogo.classList.remove('hidden');
    } else {
      document.documentElement.classList.remove('dark');
      lightLogo.classList.remove('hidden');
      darkLogo.classList.add('hidden');
    }
  })();
</script>
    <link rel="stylesheet" href="/css/bookshop.css" />
    <link rel="stylesheet" href="/css/styles.css" />
    <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
    <script src="/pagefind/pagefind-ui.js"></script>
    <script type="module" src="/assets/js/table-saw.js"></script>
    <style>
  
    :root {
      --pagefind-ui-primary: var(--text-primary);
      --pagefind-ui-text: var(--text-primary);
      --pagefind-ui-background: var(--background-body);
      --pagefind-ui-border: var(--border-primary);
      --pagefind-ui-tag: var(--text-muted);
    }
  
</style>
    {{site.customCode.headCode}}
    {{customCode.headCode}}
  </head>
  <body
    class="  flex flex-col h-screen text-lg "
  >
    {% include "partials/banner.html" %}
    <main
      tabindex="-1"
      id="main-content"
      class="flex flex-1 flex-col [&>:last-child]:flex-1 "
    >
      {% block content %}{% endblock %}
    </main>
    {% comment %}
    {% include "partials/site-foot.html" %} 
    {% endcomment %}

    <script src="https://unpkg.com/hyperscript.org@0.9.11"></script>
    <script defer>
  // The previous scroll position
  let prevScrollpos = window.pageYOffset;
  // The position where the last downward scroll started
  let scrollDownStartPos = null;

  window.onscroll = function () {
    const nav = document.getElementById("mobile-navbar");
    // Exit if the navbar isn't on the page to prevent errors
    if (!nav) return; 

    const currentScrollPos = window.pageYOffset;
    // The distance in pixels to scroll down before the navbar hides
    const scrollThreshold = 200; 
    // An optional threshold to prevent the effect from happening at the very top of the page
    const topThreshold = 250; 

    // Check if scrolling down
    if (prevScrollpos < currentScrollPos) {
      // If this is the start of a new downward scroll, record the starting position
      if (scrollDownStartPos === null) {
        scrollDownStartPos = prevScrollpos;
      }

      // Hide the navbar only if past the top threshold AND scrolled down more than the scrollThreshold
      if (
        currentScrollPos > topThreshold &&
        (currentScrollPos - scrollDownStartPos) > scrollThreshold
      ) {
        nav.style.top = "-" + nav.offsetHeight + "px";
      }
    } else { // This block executes when scrolling up
      // Always show the navbar when scrolling up
      nav.style.top = "0";
      // Reset the downward scroll tracker since we are now scrolling up
      scrollDownStartPos = null;
    }

    // Update the previous scroll position for the next scroll event
    prevScrollpos = currentScrollPos;
  };
</script>

  <script defer>

      /**
     * A lightweight youtube embed. Still should feel the same to the user, just MUCH faster to initialize and paint.
     *
     * Thx to these as the inspiration
     *   https://storage.googleapis.com/amp-vs-non-amp/youtube-lazy.html
     *   https://autoplay-youtube-player.glitch.me/
     *
     * Once built it, I also found these:
     *   https://github.com/ampproject/amphtml/blob/master/extensions/amp-youtube (ðŸ‘ðŸ‘)
     *   https://github.com/Daugilas/lazyYT
     *   https://github.com/vb/lazyframe
     */
    class LiteYTEmbed extends HTMLElement {
    connectedCallback() {
        this.videoId = this.getAttribute('videoid');
        this.thumbOnly = this.hasAttribute('thumbOnly');

        let playBtnEl = this.querySelector('.lty-playbtn');
        // A label for the button takes priority over a [playlabel] attribute on the custom-element
        this.playLabel = (playBtnEl && playBtnEl.textContent.trim()) || this.getAttribute('playlabel') || 'Play';

        this.dataset.title = this.getAttribute('title') || "";

        /**
         * Lo, the youtube poster image!  (aka the thumbnail, image placeholder, etc)
         *
         * See https://github.com/paulirish/lite-youtube-embed/blob/master/youtube-thumbnail-urls.md
         */
        if (!this.style.backgroundImage) {
          this.style.backgroundImage = `url("https://i.ytimg.com/vi/${this.videoId}/hqdefault.jpg")`;
          this.upgradePosterImage();
        }

        // Set up play button, and its visually hidden label
        if (!playBtnEl) {
            playBtnEl = document.createElement('button');
            playBtnEl.type = 'button';
            playBtnEl.classList.add('lty-playbtn');
            this.append(playBtnEl);
        }
        if (!playBtnEl.textContent) {
            const playBtnLabelEl = document.createElement('span');
            playBtnLabelEl.className = 'lyt-visually-hidden';
            playBtnLabelEl.textContent = this.playLabel;
            playBtnEl.append(playBtnLabelEl);
        }

        this.addNoscriptIframe();

        // for the PE pattern, change anchor's semantics to button
        if(playBtnEl.nodeName === 'A'){
            playBtnEl.removeAttribute('href');
            playBtnEl.setAttribute('tabindex', '0');
            playBtnEl.setAttribute('role', 'button');
            // fake button needs keyboard help
            playBtnEl.addEventListener('keydown', e => {
                if( e.key === 'Enter' || e.key === ' ' ){
                    e.preventDefault();
                    this.activate();
                }
            });
        }

        if(this.thumbOnly) {
          return;
        }
        // On hover (or tap), warm up the TCP connections we're (likely) about to use.
        this.addEventListener('pointerover', LiteYTEmbed.warmConnections, {once: true});
        this.addEventListener('focusin', LiteYTEmbed.warmConnections, {once: true});

        // Once the user clicks, add the real iframe and drop our play button
        // TODO: In the future we could be like amp-youtube and silently swap in the iframe during idle time
        //   We'd want to only do this for in-viewport or near-viewport ones: https://github.com/ampproject/amphtml/pull/5003
        this.addEventListener('click', this.activate);

        // Chrome & Edge desktop have no problem with the basic YouTube Embed with ?autoplay=1
        // However Safari desktop and most/all mobile browsers do not successfully track the user gesture of clicking through the creation/loading of the iframe,
        // so they don't autoplay automatically. Instead we must load an additional 2 sequential JS files (1KB + 165KB) (un-br) for the YT Player API
        // TODO: Try loading the the YT API in parallel with our iframe and then attaching/playing it. #82
        this.needsYTApi = this.hasAttribute("js-api") || navigator.vendor.includes('Apple') || navigator.userAgent.includes('Mobi');
    }

    /**
     * Add a <link rel={preload | preconnect} ...> to the head
     */
    static addPrefetch(kind, url, as) {
        const linkEl = document.createElement('link');
        linkEl.rel = kind;
        linkEl.href = url;
        if (as) {
            linkEl.as = as;
        }
        document.head.append(linkEl);
    }

    /**
     * Begin pre-connecting to warm up the iframe load
     * Since the embed's network requests load within its iframe,
     *   preload/prefetch'ing them outside the iframe will only cause double-downloads.
     * So, the best we can do is warm up a few connections to origins that are in the critical path.
     *
     * Maybe `<link rel=preload as=document>` would work, but it's unsupported: http://crbug.com/593267
     * But TBH, I don't think it'll happen soon with Site Isolation and split caches adding serious complexity.
     */
    static warmConnections() {
        if (LiteYTEmbed.preconnected) return;

        // The iframe document and most of its subresources come right off youtube.com
        LiteYTEmbed.addPrefetch('preconnect', 'https://www.youtube-nocookie.com');
        // The botguard script is fetched off from google.com
        LiteYTEmbed.addPrefetch('preconnect', 'https://www.google.com');

        // Not certain if these ad related domains are in the critical path. Could verify with domain-specific throttling.
        LiteYTEmbed.addPrefetch('preconnect', 'https://googleads.g.doubleclick.net');
        LiteYTEmbed.addPrefetch('preconnect', 'https://static.doubleclick.net');

        LiteYTEmbed.preconnected = true;
    }

    fetchYTPlayerApi() {
        if (window.YT || (window.YT && window.YT.Player)) return;

        this.ytApiPromise = new Promise((res, rej) => {
            var el = document.createElement('script');
            el.src = 'https://www.youtube.com/iframe_api';
            el.async = true;
            el.onload = _ => {
                YT.ready(res);
            };
            el.onerror = rej;
            this.append(el);
        });
    }

    /** Return the YT Player API instance. (Public L-YT-E API) */
    async getYTPlayer() {
        if(!this.playerPromise) {
            await this.activate();
        }

        return this.playerPromise;
    }

    async addYTPlayerIframe() {
        this.fetchYTPlayerApi();
        await this.ytApiPromise;

        const videoPlaceholderEl = document.createElement('div')
        this.append(videoPlaceholderEl);

        const paramsObj = Object.fromEntries(this.getParams().entries());

        this.playerPromise = new Promise(resolve => {
            let player = new YT.Player(videoPlaceholderEl, {
                width: '100%',
                videoId: this.videoId,
                playerVars: paramsObj,
                events: {
                    'onReady': event => {
                        event.target.playVideo();
                        resolve(player);
                    }
                }
            });
        });
    }

    // Add the iframe within <noscript> for indexability discoverability. See https://github.com/paulirish/lite-youtube-embed/issues/105
    addNoscriptIframe() {
        const iframeEl = this.createBasicIframe();
        const noscriptEl = document.createElement('noscript');
        // Appending into noscript isn't equivalant for mysterious reasons: https://html.spec.whatwg.org/multipage/scripting.html#the-noscript-element
        noscriptEl.innerHTML = iframeEl.outerHTML;
        this.append(noscriptEl);
    }

    getParams() {
        const params = new URLSearchParams(this.getAttribute('params') || []);
        params.append('autoplay', '1');
        params.append('playsinline', '1');
        return params;
    }

    async activate(){
        if (this.classList.contains('lyt-activated')) return;
        this.classList.add('lyt-activated');

        if (this.needsYTApi) {
            return this.addYTPlayerIframe(this.getParams());
        }

        const iframeEl = this.createBasicIframe();
        this.append(iframeEl);

        // Set focus for a11y
        iframeEl.focus();
    }

    createBasicIframe(){
        const iframeEl = document.createElement('iframe');
        iframeEl.width = 560;
        iframeEl.height = 315;
        // No encoding necessary as [title] is safe. https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#:~:text=Safe%20HTML%20Attributes%20include
        iframeEl.title = this.playLabel;
        iframeEl.allow = 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture';
        iframeEl.allowFullscreen = true;
        // AFAIK, the encoding here isn't necessary for XSS, but we'll do it only because this is a URL
        // https://stackoverflow.com/q/64959723/89484
        iframeEl.src = `https://www.youtube-nocookie.com/embed/${encodeURIComponent(this.videoId)}?${this.getParams().toString()}`;
        return iframeEl;
    }

    /**
     * In the spirit of the `lowsrc` attribute and progressive JPEGs, we'll upgrade the reliable
     * poster image to a higher resolution one, if it's available.
     * Interestingly this sddefault webp is often smaller in filesize, but we will still attempt it second
     * because getting _an_ image in front of the user if our first priority.
     *
     * See https://github.com/paulirish/lite-youtube-embed/blob/master/youtube-thumbnail-urls.md for more details
     */
    upgradePosterImage() {
         // Defer to reduce network contention.
        setTimeout(() => {
            const webpUrl = `https://i.ytimg.com/vi_webp/${this.videoId}/sddefault.webp`;
            const img = new Image();
            img.fetchPriority = 'low'; // low priority to reduce network contention
            img.referrerpolicy = 'origin'; // Not 100% sure it's needed, but https://github.com/ampproject/amphtml/pull/3940
            img.src = webpUrl;
            img.onload = e => {
                // A pretty ugly hack since onerror won't fire on YouTube image 404. This is (probably) due to
                // Youtube's style of returning data even with a 404 status. That data is a 120x90 placeholder image.
                // â€¦ per "annoying yt 404 behavior" in the .md
                const noAvailablePoster = e.target.naturalHeight == 90 && e.target.naturalWidth == 120;
                if (noAvailablePoster) return;

                this.style.backgroundImage = `url("${webpUrl}")`;
            }
        }, 100);
    }
    }
    // Register custom element
    customElements.define('lite-youtube', LiteYTEmbed);
  </script>

  <script defer>
    class LiteVimeo extends (globalThis.HTMLElement ?? class {}) {
            /**
             * Begin pre-connecting to warm up the iframe load
             * Since the embed's network requests load within its iframe,
             *   preload/prefetch'ing them outside the iframe will only cause double-downloads.
             * So, the best we can do is warm up a few connections to origins that are in the critical path.
             *
             * Maybe `<link rel=preload as=document>` would work, but it's unsupported: http://crbug.com/593267
             * But TBH, I don't think it'll happen soon with Site Isolation and split caches adding serious complexity.
             */
            static _warmConnections() {
              if (LiteVimeo.preconnected) return;
              LiteVimeo.preconnected = true;
          
              // The iframe document and most of its subresources come right off player.vimeo.com
              addPrefetch('preconnect', 'https://player.vimeo.com');
              // Images
              addPrefetch('preconnect', 'https://i.vimeocdn.com');
              // Files .js, .css
              addPrefetch('preconnect', 'https://f.vimeocdn.com');
              // Metrics
              addPrefetch('preconnect', 'https://fresnel.vimeocdn.com');
            }
          
            connectedCallback() {
              this.videoId = this.getAttribute('videoid');
              this.thumbOnly = this.hasAttribute('thumbOnly');
          
              /**
               * Lo, the vimeo placeholder image!  (aka the thumbnail, poster image, etc)
               * We have to use the Vimeo API.
               */
              let { width, height } = getThumbnailDimensions(this.getBoundingClientRect());
              let devicePixelRatio = window.devicePixelRatio || 1;
              if (devicePixelRatio >= 2) devicePixelRatio *= .75;
              width = Math.round(width * devicePixelRatio);
              height = Math.round(height * devicePixelRatio);
          
              fetch(`https://vimeo.com/api/v2/video/${this.videoId}.json`)
                .then(response => response.json())
                .then(data => {
                  let thumbnailUrl = data[0].thumbnail_large;
                  thumbnailUrl = thumbnailUrl.replace(/-d_[\dx]+$/i, `-d_${width}x${height}`);
                  this.style.backgroundImage = `url("${thumbnailUrl}")`;
                });
          
              let playBtnEl = this.querySelector('.ltv-playbtn');
              // A label for the button takes priority over a [playlabel] attribute on the custom-element
              this.playLabel = (playBtnEl && playBtnEl.textContent.trim()) || this.getAttribute('playlabel') || 'Play video';
          
              if (!playBtnEl) {
                playBtnEl = document.createElement('button');
                playBtnEl.type = 'button';
                playBtnEl.setAttribute('aria-label', this.playLabel);
                playBtnEl.classList.add('ltv-playbtn');
                this.append(playBtnEl);
              }
              playBtnEl.removeAttribute('href');
              
              if (this.thumbOnly) {
                return;
              }
              // On hover (or tap), warm up the TCP connections we're (likely) about to use.
              this.addEventListener('pointerover', LiteVimeo._warmConnections, {
                once: true
              });
          
              // Once the user clicks, add the real iframe and drop our play button
              // TODO: In the future we could be like amp-youtube and silently swap in the iframe during idle time
              //   We'd want to only do this for in-viewport or near-viewport ones: https://github.com/ampproject/amphtml/pull/5003
              this.addEventListener('click', this.addIframe);
            }
          
            addIframe() {
              if (this.classList.contains('ltv-activated')) return;
              this.classList.add('ltv-activated');
          
              const iframeEl = document.createElement('iframe');
              iframeEl.width = 640;
              iframeEl.height = 360;
              // No encoding necessary as [title] is safe. https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#:~:text=Safe%20HTML%20Attributes%20include
              iframeEl.title = this.playLabel;
              iframeEl.allow = 'fullscreen; accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture';
              // AFAIK, the encoding here isn't necessary for XSS, but we'll do it only because this is a URL
              // https://stackoverflow.com/q/64959723/89484
              iframeEl.src = `https://player.vimeo.com/video/${encodeURIComponent(this.videoId)}?autoplay=1`;
              this.append(iframeEl);
          
              // Set focus for a11y
              iframeEl.addEventListener('load', iframeEl.focus, { once: true });
            }
          }
          
          if (globalThis.customElements && !globalThis.customElements.get('lite-vimeo')) {
            globalThis.customElements.define('lite-vimeo', LiteVimeo);
          }
          
          /**
           * Add a <link rel={preload | preconnect} ...> to the head
           */
          function addPrefetch(kind, url, as) {
            const linkElem = document.createElement('link');
            linkElem.rel = kind;
            linkElem.href = url;
            if (as) {
              linkElem.as = as;
            }
            linkElem.crossorigin = true;
            document.head.append(linkElem);
          }
          
          /**
           * Get the thumbnail dimensions to use for a given player size.
           *
           * @param {Object} options
           * @param {number} options.width The width of the player
           * @param {number} options.height The height of the player
           * @return {Object} The width and height
           */
          function getThumbnailDimensions({ width, height }) {
            let roundedWidth = width;
            let roundedHeight = height;
          
            // If the original width is a multiple of 320 then we should
            // not round up. This is to keep the native image dimensions
            // so that they match up with the actual frames from the video.
            //
            // For example 640x360, 960x540, 1280x720, 1920x1080
            //
            // Round up to nearest 100 px to improve cacheability at the
            // CDN. For example, any width between 601 pixels and 699
            // pixels will render the thumbnail at 700 pixels width.
            if (roundedWidth % 320 !== 0) {
              roundedWidth = Math.ceil(width / 100) * 100;
              roundedHeight = Math.round((roundedWidth / width) * height);
            }
          
            return {
              width: roundedWidth,
              height: roundedHeight
            };
          }
  </script>
  <script>
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: true });
    });
</script>

<script>
  const inactive = tab => tab.classList.remove('active')
const active = tab => tab.classList.add('active')
const tabClick = tab => tab.addEventListener('click', listener)

const listener = (event) => {
  // id for the clicked button
  const tabId = event.target.getAttribute('data-id')
  // the parent container's id
  const containerId = event.target.parentElement.parentElement.getAttribute('data-id')
  // syntax sugar for self
  const parentQuery = `.tabs-tabs-wrapper[data-id=${containerId}]`

  // Set everything in this parent container to inactive
  document.querySelectorAll(`${parentQuery} .tabs-tab-content`).forEach(inactive)
  document.querySelectorAll(`${parentQuery} .tabs-tabs-header button`).forEach(inactive)

  // Set the tab id's items to active
  document.querySelectorAll(`[data-id=${tabId}]`).forEach(active)
}

// Set it up for all my homies (multiple tabs)
document.querySelectorAll('.tabs-tabs-header button').forEach(tabClick)
</script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Get references to the DOM elements
    const sunIcon = document.getElementById('sun-icon');
    const sunIconMobile = document.getElementById('sun-icon-mobile');
    const moonIconMobile = document.getElementById('moon-icon-mobile');
    const moonIcon = document.getElementById('moon-icon');
    const lightLogo = document.getElementById('logoLight');
    const darkLogo = document.getElementById('logoDark');
    const toggleButtons = document.querySelectorAll('#dark-toggle, #dark-toggle-mobile');

    /**
     * Applies the theme to the DOM by updating classes on the html tag and icons.
     * @param {string} theme - The theme to apply ('system', 'light', or 'dark').
     */
    const applyTheme = (theme) => {
      // Update the <html> element class
      if (theme === 'light') {
        document.documentElement.classList.remove('dark');
      } else if (theme === 'dark') {
        document.documentElement.classList.add('dark');
      } else { // 'system'
        // Respect the OS preference
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        document.documentElement.classList.toggle('dark', prefersDark);
      }

      // Update icon visibility
      if (sunIcon && moonIcon) {
        if (theme === 'light') {
          sunIcon.classList.remove('hidden');
          moonIcon.classList.add('hidden');
          sunIconMobile.classList.remove('hidden');
          moonIconMobile.classList.add('hidden');
          lightLogo.classList.remove('hidden');
          darkLogo.classList.add('hidden');
        } else if (theme === 'dark') {
          sunIcon.classList.add('hidden');
          moonIcon.classList.remove('hidden');
          sunIconMobile.classList.add('hidden');
          moonIconMobile.classList.remove('hidden');
          lightLogo.classList.add('hidden');
          darkLogo.classList.remove('hidden');
        } else { // 'system'
          sunIcon.classList.remove('hidden');
          moonIcon.classList.remove('hidden');
          sunIconMobile.classList.remove('hidden');
          moonIconMobile.classList.remove('hidden');
          if (
      localStorage.theme === 'dark' || 
      (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)
        ) {
          
              darkLogo.classList.remove('hidden');
              lightLogo.classList.add('hidden');
        }else {
          
              darkLogo.classList.add('hidden');
              lightLogo.classList.remove('hidden');
        }
        }
      }
    };

    /**
     * Handles the click event to cycle through themes.
     */
    const handleThemeToggle = () => {
      let currentTheme = localStorage.getItem('theme') || 'system';

      // Cycle through the states: system -> dark -> light -> system
      if (currentTheme === 'system') {
        currentTheme = 'dark';
      } else if (currentTheme === 'dark') {
        currentTheme = 'light';
      } else {
        currentTheme = 'system';
      }

      // Update localStorage
      if (currentTheme === 'system') {
        localStorage.removeItem('theme');
      } else {
        localStorage.setItem('theme', currentTheme);
      }

      // Apply the new theme to the page
      applyTheme(currentTheme);
    };

    // --- Initialization ---

    // 1. Set the initial theme on page load
    const initialTheme = localStorage.getItem('theme') || 'system';
    applyTheme(initialTheme);

    // 2. Add click listeners to all toggle buttons
    toggleButtons.forEach(button => {
      button.addEventListener('click', handleThemeToggle);
    });
  });
</script>

{% mermaid_js %}


    {{site.customCode.bodyCode}}
    {{customCode.bodyCode}}
  </body>
</html>
